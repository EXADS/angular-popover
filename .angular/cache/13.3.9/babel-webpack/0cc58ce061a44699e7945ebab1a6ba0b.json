{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, TemplateRef, Component, ChangeDetectionStrategy, ViewEncapsulation, HostBinding, Input, Output, ViewChild, Directive, Optional, HostListener, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i1$1 from '@angular/cdk/overlay';\nimport { OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport * as i2 from '@angular/cdk/a11y';\nimport { isFakeMousedownFromScreenReader, A11yModule } from '@angular/cdk/a11y';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport * as i2$1 from '@angular/cdk/bidi';\n/**\n * Throws an exception for the case when popover trigger doesn't have a valid mde-popover instance\n */\n\nfunction throwMdePopoverMissingError() {\n  throw Error(`mde-popover-trigger: must pass in an mde-popover instance.\n\n    Example:\n      <mde-popover #popover=\"mdePopover\"></mde-popover>\n      <button [mdePopoverTriggerFor]=\"popover\"></button>`);\n}\n/**\n * Throws an exception for the case when popover's mdePopoverPositionX value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n */\n\n\nfunction throwMdePopoverInvalidPositionX() {\n  throw Error(`mdePopoverPositionX value must be either 'before' or after'.\n      Example: <mde-popover mdePopoverPositionX=\"before\" #popover=\"mdePopover\"></mde-popover>`);\n}\n/**\n * Throws an exception for the case when popover's mdePopoverPositionY value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n */\n\n\nfunction throwMdePopoverInvalidPositionY() {\n  throw Error(`mdePopoverPositionY value must be either 'above' or below'.\n      Example: <mde-popover mdePopoverPositionY=\"above\" #popover=\"mdePopover\"></mde-popover>`);\n}\n/**\n * Below are all the animations for the md-popover component.\n * Animation duration and timing values are based on AngularJS Material.\n */\n\n/**\n * This animation controls the popover panel's entry and exit from the page.\n *\n * When the popover panel is added to the DOM, it scales in and fades in its border.\n *\n * When the popover panel is removed from the DOM, it simply fades out after a brief\n * delay to display the ripple.\n */\n\n\nconst transformPopover = trigger('transformPopover', [state('enter', style({\n  opacity: 1,\n  transform: `scale(1)`\n})), transition('void => *', [style({\n  opacity: 0,\n  transform: `scale(0)`\n}), animate(`200ms cubic-bezier(0.25, 0.8, 0.25, 1)`)]), transition('* => void', [animate('50ms 100ms linear', style({\n  opacity: 0\n}))])]);\n\nfunction MdePopover_ng_template_0_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r1.popoverArrowStyles);\n  }\n}\n\nfunction MdePopover_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 0);\n    i0.ɵɵlistener(\"keydown\", function MdePopover_ng_template_0_Template_div_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return ctx_r2._handleKeydown($event);\n    })(\"click\", function MdePopover_ng_template_0_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.onClick();\n    })(\"mouseover\", function MdePopover_ng_template_0_Template_div_mouseover_0_listener() {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.onMouseOver();\n    })(\"mouseleave\", function MdePopover_ng_template_0_Template_div_mouseleave_0_listener() {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.onMouseLeave();\n    });\n    i0.ɵɵtemplate(1, MdePopover_ng_template_0_div_1_Template, 1, 1, \"div\", 1);\n    i0.ɵɵelementStart(2, \"div\", 2);\n    i0.ɵɵprojection(3);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"mde-popover-overlap\", ctx_r0.overlapTrigger);\n    i0.ɵɵproperty(\"ngClass\", ctx_r0._classList)(\"ngStyle\", ctx_r0.popoverPanelStyles)(\"@.disabled\", ctx_r0.disableAnimation)(\"@transformPopover\", \"enter\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.overlapTrigger);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r0.popoverContentStyles)(\"cdkTrapFocus\", ctx_r0.focusTrapEnabled)(\"cdkTrapFocusAutoCapture\", ctx_r0.focusTrapAutoCaptureEnabled);\n  }\n}\n\nconst _c0 = [\"*\"];\nlet MdePopover = /*#__PURE__*/(() => {\n  class MdePopover {\n    constructor(_elementRef, zone) {\n      this._elementRef = _elementRef;\n      this.zone = zone;\n      this.role = 'dialog';\n      /** Settings for popover, view setters and getters for more detail */\n\n      this._positionX = 'after';\n      this._positionY = 'below';\n      this._triggerEvent = 'hover';\n      this._scrollStrategy = 'reposition';\n      this._enterDelay = 200;\n      this._leaveDelay = 200;\n      this._overlapTrigger = true;\n      this._disableAnimation = false;\n      this._targetOffsetX = 0;\n      this._targetOffsetY = 0;\n      this._arrowOffsetX = 20;\n      this._arrowWidth = 8;\n      this._arrowColor = 'rgba(0, 0, 0, 0.12)';\n      this._closeOnClick = true;\n      this._focusTrapEnabled = true;\n      this._focusTrapAutoCaptureEnabled = true;\n      /** Config object to be passed into the popover's ngClass */\n\n      this._classList = {}; // TODO: Write comment description\n\n      /** */\n\n      this.containerPositioning = false;\n      /** Closing disabled on popover */\n\n      this.closeDisabled = false;\n      /** Emits the current animation state whenever it changes. */\n\n      this._onAnimationStateChange = new EventEmitter();\n      /** Event emitted when the popover is closed. */\n\n      this.close = new EventEmitter();\n      this.setPositionClasses();\n    }\n    /** Position of the popover in the X axis. */\n\n\n    get positionX() {\n      return this._positionX;\n    }\n\n    set positionX(value) {\n      if (value !== 'before' && value !== 'after') {\n        throwMdePopoverInvalidPositionX();\n      }\n\n      this._positionX = value;\n      this.setPositionClasses();\n    }\n    /** Position of the popover in the Y axis. */\n\n\n    get positionY() {\n      return this._positionY;\n    }\n\n    set positionY(value) {\n      if (value !== 'above' && value !== 'below') {\n        throwMdePopoverInvalidPositionY();\n      }\n\n      this._positionY = value;\n      this.setPositionClasses();\n    }\n    /** Popover trigger event */\n\n\n    get triggerEvent() {\n      return this._triggerEvent;\n    }\n\n    set triggerEvent(value) {\n      this._triggerEvent = value;\n    }\n    /** Popover scroll strategy */\n\n\n    get scrollStrategy() {\n      return this._scrollStrategy;\n    }\n\n    set scrollStrategy(value) {\n      this._scrollStrategy = value;\n    }\n    /** Popover enter delay */\n\n\n    get enterDelay() {\n      return this._enterDelay;\n    }\n\n    set enterDelay(value) {\n      this._enterDelay = value;\n    }\n    /** Popover leave delay */\n\n\n    get leaveDelay() {\n      return this._leaveDelay;\n    }\n\n    set leaveDelay(value) {\n      this._leaveDelay = value;\n    }\n    /** Popover overlap trigger */\n\n\n    get overlapTrigger() {\n      return this._overlapTrigger;\n    }\n\n    set overlapTrigger(value) {\n      this._overlapTrigger = value;\n    }\n    /** Popover target offset x */\n\n\n    get targetOffsetX() {\n      return this._targetOffsetX;\n    }\n\n    set targetOffsetX(value) {\n      this._targetOffsetX = value;\n    }\n    /** Popover target offset y */\n\n\n    get targetOffsetY() {\n      return this._targetOffsetY;\n    }\n\n    set targetOffsetY(value) {\n      this._targetOffsetY = value;\n    }\n    /** Popover arrow offset x */\n\n\n    get arrowOffsetX() {\n      return this._arrowOffsetX;\n    }\n\n    set arrowOffsetX(value) {\n      this._arrowOffsetX = value;\n    }\n    /** Popover arrow width */\n\n\n    get arrowWidth() {\n      return this._arrowWidth;\n    }\n\n    set arrowWidth(value) {\n      this._arrowWidth = value;\n    }\n    /** Popover arrow color */\n\n\n    get arrowColor() {\n      return this._arrowColor;\n    }\n\n    set arrowColor(value) {\n      this._arrowColor = value;\n    }\n    /**\n     * Popover container close on click\n     * default: true\n     */\n\n\n    get closeOnClick() {\n      return this._closeOnClick;\n    }\n\n    set closeOnClick(value) {\n      this._closeOnClick = coerceBooleanProperty(value);\n    }\n    /**\n     * Disable animations of popover and all child elements\n     * default: false\n     */\n\n\n    get disableAnimation() {\n      return this._disableAnimation;\n    }\n\n    set disableAnimation(value) {\n      this._disableAnimation = coerceBooleanProperty(value);\n    }\n    /**\n     * Popover focus trap using cdkTrapFocus\n     * default: true\n     */\n\n\n    get focusTrapEnabled() {\n      return this._focusTrapEnabled;\n    }\n\n    set focusTrapEnabled(value) {\n      this._focusTrapEnabled = coerceBooleanProperty(value);\n    }\n    /**\n     * Popover focus trap auto capture using cdkTrapFocusAutoCapture\n     * default: true\n     */\n\n\n    get focusTrapAutoCaptureEnabled() {\n      return this._focusTrapAutoCaptureEnabled;\n    }\n\n    set focusTrapAutoCaptureEnabled(value) {\n      this._focusTrapAutoCaptureEnabled = coerceBooleanProperty(value);\n    }\n    /**\n     * This method takes classes set on the host md-popover element and applies them on the\n     * popover template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing popover from outside the component.\n     * @param classes list of class names\n     */\n\n\n    set panelClass(classes) {\n      if (classes && classes.length) {\n        this._classList = classes.split(' ').reduce((obj, className) => {\n          obj[className] = true;\n          return obj;\n        }, {});\n        this._elementRef.nativeElement.className = '';\n        this.setPositionClasses();\n      }\n    }\n    /**\n     * This method takes classes set on the host md-popover element and applies them on the\n     * popover template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing popover from outside the component.\n     * @deprecated Use `panelClass` instead.\n     */\n\n\n    get classList() {\n      return this.panelClass;\n    }\n\n    set classList(classes) {\n      this.panelClass = classes;\n    }\n\n    ngOnDestroy() {\n      this._emitCloseEvent();\n\n      this.close.complete();\n    }\n    /** Handle a keyboard event from the popover, delegating to the appropriate action. */\n\n\n    _handleKeydown(event) {\n      switch (event.keyCode) {\n        case ESCAPE:\n          this._emitCloseEvent();\n\n          return;\n      }\n    }\n    /**\n     * This emits a close event to which the trigger is subscribed. When emitted, the\n     * trigger will close the popover.\n     */\n\n\n    _emitCloseEvent() {\n      this.close.emit();\n    }\n    /** Close popover on click if closeOnClick is true */\n\n\n    onClick() {\n      if (this.closeOnClick) {\n        this._emitCloseEvent();\n      }\n    }\n    /**\n     * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.\n     * https://github.com/angular/material2/pull/5493#issuecomment-313085323\n     */\n\n    /** Disables close of popover when leaving trigger element and mouse over the popover */\n\n\n    onMouseOver() {\n      if (this.triggerEvent === 'hover') {\n        this.closeDisabled = true;\n      }\n    }\n    /** Enables close of popover when mouse leaving popover element */\n\n\n    onMouseLeave() {\n      if (this.triggerEvent === 'hover') {\n        this.closeDisabled = false;\n\n        this._emitCloseEvent();\n      }\n    } // TODO: Refactor how styles are set and updated on the component, use best practices.\n    // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.\n\n    /** Sets the current styles for the popover to allow for dynamically changing settings */\n\n\n    setCurrentStyles() {\n      // TODO: See if arrow position can be calculated automatically and allow override.\n      // TODO: See if flex order is a better alternative to position arrow top or bottom.\n      this.popoverArrowStyles = {\n        'right': this.positionX === 'before' ? this.arrowOffsetX - this.arrowWidth + 'px' : '',\n        'left': this.positionX === 'after' ? this.arrowOffsetX - this.arrowWidth + 'px' : '',\n        'border-top': this.positionY === 'below' ? this.arrowWidth + 'px solid ' + this.arrowColor : '0px solid transparent',\n        'border-right': 'undefined' === undefined ? this.arrowWidth + 'px solid ' + this.arrowColor : this.arrowWidth + 'px solid transparent',\n        'border-bottom': this.positionY === 'above' ? this.arrowWidth + 'px solid ' + this.arrowColor : this.arrowWidth + 'px solid transparent',\n        'border-left': 'undefined' === undefined ? this.arrowWidth + 'px solid ' + this.arrowColor : this.arrowWidth + 'px solid transparent'\n      }; // TODO: Remove if flex order is added.\n\n      this.popoverContentStyles = {\n        'padding-top': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',\n        'padding-bottom': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',\n        'margin-top': this.overlapTrigger === false && this.positionY === 'below' && this.containerPositioning === false ? -(this.arrowWidth * 2) + 'px' : '0px'\n      };\n    }\n    /**\n     * It's necessary to set position-based classes to ensure the popover panel animation\n     * folds out from the correct direction.\n     */\n\n\n    setPositionClasses(posX = this.positionX, posY = this.positionY) {\n      this._classList['mde-popover-before'] = posX === 'before';\n      this._classList['mde-popover-after'] = posX === 'after';\n      this._classList['mde-popover-above'] = posY === 'above';\n      this._classList['mde-popover-below'] = posY === 'below';\n    }\n\n  }\n\n  MdePopover.ɵfac = function MdePopover_Factory(t) {\n    return new (t || MdePopover)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MdePopover.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: MdePopover,\n    selectors: [[\"mde-popover\"]],\n    viewQuery: function MdePopover_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(TemplateRef, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);\n      }\n    },\n    hostVars: 1,\n    hostBindings: function MdePopover_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n      }\n    },\n    inputs: {\n      positionX: [\"mdePopoverPositionX\", \"positionX\"],\n      positionY: [\"mdePopoverPositionY\", \"positionY\"],\n      triggerEvent: [\"mdePopoverTriggerOn\", \"triggerEvent\"],\n      scrollStrategy: [\"mdePopoverScrollStrategy\", \"scrollStrategy\"],\n      enterDelay: [\"mdePopoverEnterDelay\", \"enterDelay\"],\n      leaveDelay: [\"mdePopoverLeaveDelay\", \"leaveDelay\"],\n      overlapTrigger: [\"mdePopoverOverlapTrigger\", \"overlapTrigger\"],\n      targetOffsetX: [\"mdePopoverOffsetX\", \"targetOffsetX\"],\n      targetOffsetY: [\"mdePopoverOffsetY\", \"targetOffsetY\"],\n      arrowOffsetX: [\"mdePopoverArrowOffsetX\", \"arrowOffsetX\"],\n      arrowWidth: [\"mdePopoverArrowWidth\", \"arrowWidth\"],\n      arrowColor: [\"mdePopoverArrowColor\", \"arrowColor\"],\n      closeOnClick: [\"mdePopoverCloseOnClick\", \"closeOnClick\"],\n      disableAnimation: [\"mdePopoverDisableAnimation\", \"disableAnimation\"],\n      focusTrapEnabled: [\"mdeFocusTrapEnabled\", \"focusTrapEnabled\"],\n      focusTrapAutoCaptureEnabled: [\"mdeFocusTrapAutoCaptureEnabled\", \"focusTrapAutoCaptureEnabled\"],\n      panelClass: [\"class\", \"panelClass\"],\n      classList: \"classList\"\n    },\n    outputs: {\n      close: \"close\"\n    },\n    exportAs: [\"mdePopover\"],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    consts: [[\"role\", \"dialog\", 1, \"mde-popover-panel\", 3, \"ngClass\", \"ngStyle\", \"keydown\", \"click\", \"mouseover\", \"mouseleave\"], [\"class\", \"mde-popover-direction-arrow\", 3, \"ngStyle\", 4, \"ngIf\"], [1, \"mde-popover-content\", 3, \"ngStyle\", \"cdkTrapFocus\", \"cdkTrapFocusAutoCapture\"], [1, \"mde-popover-direction-arrow\", 3, \"ngStyle\"]],\n    template: function MdePopover_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, MdePopover_ng_template_0_Template, 4, 10, \"ng-template\");\n      }\n    },\n    directives: [i1.NgClass, i1.NgStyle, i1.NgIf, i2.CdkTrapFocus],\n    styles: [\".mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0px;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}\\n\"],\n    encapsulation: 2,\n    data: {\n      animation: [transformPopover]\n    },\n    changeDetection: 0\n  });\n  return MdePopover;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * This directive is intended to be used in conjunction with an mde-popover tag. It is\n * responsible for toggling the display of the provided popover instance.\n */\n\n\nlet MdePopoverTrigger = /*#__PURE__*/(() => {\n  class MdePopoverTrigger {\n    constructor(_overlay, _elementRef, _viewContainerRef, _dir, _changeDetectorRef) {\n      this._overlay = _overlay;\n      this._elementRef = _elementRef;\n      this._viewContainerRef = _viewContainerRef;\n      this._dir = _dir;\n      this._changeDetectorRef = _changeDetectorRef;\n      this.ariaHaspopup = true;\n      this.popoverOpened = new Subject();\n      this.popoverClosed = new Subject();\n      this._overlayRef = null;\n      this._popoverOpen = false;\n      this._halt = false; // tracking input type is necessary so it's possible to only auto-focus\n      // the first item of the list when the popover is opened via the keyboard\n\n      this._openedByMouse = false;\n      this._onDestroy = new Subject();\n      /** Popover backdrop close on click */\n\n      this.backdropCloseOnClick = true;\n      /** Event emitted when the associated popover is opened. */\n\n      this.opened = new EventEmitter();\n      /** Event emitted when the associated popover is closed. */\n\n      this.closed = new EventEmitter();\n    }\n\n    ngAfterViewInit() {\n      this._checkPopover();\n\n      this._setCurrentConfig();\n\n      this.popover.close.subscribe(() => this.closePopover());\n    }\n\n    ngOnDestroy() {\n      this.destroyPopover();\n    }\n\n    _setCurrentConfig() {\n      if (this.positionX === 'before' || this.positionX === 'after') {\n        this.popover.positionX = this.positionX;\n      }\n\n      if (this.positionY === 'above' || this.positionY === 'below') {\n        this.popover.positionY = this.positionY;\n      }\n\n      if (this.triggerEvent) {\n        this.popover.triggerEvent = this.triggerEvent;\n      }\n\n      if (this.enterDelay) {\n        this.popover.enterDelay = this.enterDelay;\n      }\n\n      if (this.leaveDelay) {\n        this.popover.leaveDelay = this.leaveDelay;\n      }\n\n      if (this.overlapTrigger === true || this.overlapTrigger === false) {\n        this.popover.overlapTrigger = this.overlapTrigger;\n      }\n\n      if (this.targetOffsetX) {\n        this.popover.targetOffsetX = this.targetOffsetX;\n      }\n\n      if (this.targetOffsetY) {\n        this.popover.targetOffsetY = this.targetOffsetY;\n      }\n\n      if (this.arrowOffsetX) {\n        this.popover.arrowOffsetX = this.arrowOffsetX;\n      }\n\n      if (this.arrowWidth) {\n        this.popover.arrowWidth = this.arrowWidth;\n      }\n\n      if (this.arrowColor) {\n        this.popover.arrowColor = this.arrowColor;\n      }\n\n      if (this.closeOnClick === true || this.closeOnClick === false) {\n        this.popover.closeOnClick = this.closeOnClick;\n      }\n\n      this.popover.setCurrentStyles();\n    }\n    /** Whether the popover is open. */\n\n\n    get popoverOpen() {\n      return this._popoverOpen;\n    }\n\n    onClick(event) {\n      if (this.popover.triggerEvent === 'click') {\n        this.togglePopover();\n      }\n    }\n\n    onMouseEnter(event) {\n      this._halt = false;\n\n      if (this.popover.triggerEvent === 'hover') {\n        this._mouseoverTimer = setTimeout(() => {\n          this.openPopover();\n        }, this.popover.enterDelay);\n      }\n    }\n\n    onMouseLeave(event) {\n      if (this.popover.triggerEvent === 'hover') {\n        if (this._mouseoverTimer) {\n          clearTimeout(this._mouseoverTimer);\n          this._mouseoverTimer = null;\n        }\n\n        if (this._popoverOpen) {\n          setTimeout(() => {\n            if (!this.popover.closeDisabled) {\n              this.closePopover();\n            }\n          }, this.popover.leaveDelay);\n        } else {\n          this._halt = true;\n        }\n      }\n    }\n    /** Toggles the popover between the open and closed states. */\n\n\n    togglePopover() {\n      return this._popoverOpen ? this.closePopover() : this.openPopover();\n    }\n    /** Opens the popover. */\n\n\n    openPopover() {\n      if (!this._popoverOpen && !this._halt) {\n        this._createOverlay().attach(this._portal);\n\n        this._subscribeToBackdrop();\n\n        this._subscribeToDetachments();\n\n        this._initPopover();\n      }\n    }\n    /** Closes the popover. */\n\n\n    closePopover() {\n      if (this._overlayRef) {\n        this._overlayRef.detach();\n\n        this._resetPopover();\n      }\n    }\n    /** Removes the popover from the DOM. */\n\n\n    destroyPopover() {\n      if (this._mouseoverTimer) {\n        clearTimeout(this._mouseoverTimer);\n        this._mouseoverTimer = null;\n      }\n\n      if (this._overlayRef) {\n        this._overlayRef.dispose();\n\n        this._overlayRef = null;\n\n        this._cleanUpSubscriptions();\n      }\n\n      this._onDestroy.next();\n\n      this._onDestroy.complete();\n    }\n    /** Focuses the popover trigger. */\n\n\n    focus() {\n      this._elementRef.nativeElement.focus();\n    }\n    /** The text direction of the containing app. */\n\n\n    get dir() {\n      return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /**\n    * This method ensures that the popover closes when the overlay backdrop is clicked.\n    * We do not use first() here because doing so would not catch clicks from within\n    * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe\n    * explicitly when the popover is closed or destroyed.\n    */\n\n\n    _subscribeToBackdrop() {\n      if (this._overlayRef) {\n        /** Only subscribe to backdrop if trigger event is click */\n        if (this.triggerEvent === 'click' && this.backdropCloseOnClick === true) {\n          this._overlayRef.backdropClick().pipe(takeUntil(this.popoverClosed), takeUntil(this._onDestroy)).subscribe(() => {\n            this.popover._emitCloseEvent();\n          });\n        }\n      }\n    }\n\n    _subscribeToDetachments() {\n      if (this._overlayRef) {\n        this._overlayRef.detachments().pipe(takeUntil(this.popoverClosed), takeUntil(this._onDestroy)).subscribe(() => {\n          this._setPopoverClosed();\n        });\n      }\n    }\n    /**\n    * This method sets the popover state to open and focuses the first item if\n    * the popover was opened via the keyboard.\n    */\n\n\n    _initPopover() {\n      this._setPopoverOpened();\n    }\n    /**\n    * This method resets the popover when it's closed, most importantly restoring\n    * focus to the popover trigger if the popover was opened via the keyboard.\n    */\n\n\n    _resetPopover() {\n      this._setPopoverClosed(); // Focus only needs to be reset to the host element if the popover was opened\n      // by the keyboard and manually shifted to the first popover item.\n\n\n      if (!this._openedByMouse) {\n        this.focus();\n      }\n\n      this._openedByMouse = false;\n    }\n    /** set state rather than toggle to support triggers sharing a popover */\n\n\n    _setPopoverOpened() {\n      if (!this._popoverOpen) {\n        this._popoverOpen = true;\n        this.popoverOpened.next();\n        this.opened.emit();\n      }\n    }\n    /** set state rather than toggle to support triggers sharing a popover */\n\n\n    _setPopoverClosed() {\n      if (this._popoverOpen) {\n        this._popoverOpen = false;\n        this.popoverClosed.next();\n        this.closed.emit();\n      }\n    }\n    /**\n    *  This method checks that a valid instance of MdPopover has been passed into\n    *  mdPopoverTriggerFor. If not, an exception is thrown.\n    */\n\n\n    _checkPopover() {\n      if (!this.popover) {\n        throwMdePopoverMissingError();\n      }\n    }\n    /**\n    *  This method creates the overlay from the provided popover's template and saves its\n    *  OverlayRef so that it can be attached to the DOM when openPopover is called.\n    */\n\n\n    _createOverlay() {\n      if (!this._overlayRef) {\n        this._portal = new TemplatePortal(this.popover.templateRef, this._viewContainerRef);\n\n        const config = this._getOverlayConfig();\n\n        this._subscribeToPositions(config.positionStrategy);\n\n        this._overlayRef = this._overlay.create(config);\n      }\n\n      return this._overlayRef;\n    }\n    /**\n    * This method builds the configuration object needed to create the overlay, the OverlayConfig.\n    * @returns OverlayConfig\n    */\n\n\n    _getOverlayConfig() {\n      const overlayState = new OverlayConfig();\n      overlayState.positionStrategy = this._getPosition();\n      /** Display overlay backdrop if trigger event is click */\n\n      if (this.triggerEvent === 'click') {\n        overlayState.hasBackdrop = true;\n        overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';\n      }\n\n      overlayState.direction = this.dir;\n      overlayState.scrollStrategy = this._getOverlayScrollStrategy(this.popover.scrollStrategy);\n      return overlayState;\n    }\n    /**\n     * This method returns the scroll strategy used by the cdk/overlay.\n     */\n\n\n    _getOverlayScrollStrategy(strategy) {\n      switch (strategy) {\n        case 'noop':\n          return this._overlay.scrollStrategies.noop();\n\n        case 'close':\n          return this._overlay.scrollStrategies.close();\n\n        case 'block':\n          return this._overlay.scrollStrategies.block();\n\n        case 'reposition':\n        default:\n          return this._overlay.scrollStrategies.reposition();\n      }\n    }\n    /**\n    * Listens to changes in the position of the overlay and sets the correct classes\n    * on the popover based on the new position. This ensures the animation origin is always\n    * correct, even if a fallback position is used for the overlay.\n    */\n\n\n    _subscribeToPositions(position) {\n      this._positionSubscription = position.positionChanges.subscribe(change => {\n        const posisionX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n        let posisionY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n\n        if (!this.popover.overlapTrigger) {\n          posisionY = posisionY === 'below' ? 'above' : 'below';\n        } // required for ChangeDetectionStrategy.OnPush\n\n\n        this._changeDetectorRef.markForCheck();\n\n        this.popover.zone.run(() => {\n          this.popover.positionX = posisionX;\n          this.popover.positionY = posisionY;\n          this.popover.setCurrentStyles();\n          this.popover.setPositionClasses(posisionX, posisionY);\n        });\n      });\n    }\n    /**\n    * This method builds the position strategy for the overlay, so the popover is properly connected\n    * to the trigger.\n    * @returns ConnectedPositionStrategy\n    */\n\n\n    _getPosition() {\n      const [originX, originFallbackX] = this.popover.positionX === 'before' ? ['end', 'start'] : ['start', 'end'];\n      const [overlayY, overlayFallbackY] = this.popover.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom']; // let originY = overlayY;\n      // let fallbackOriginY = overlayFallbackY;\n\n      let originY = overlayY;\n      let originFallbackY = overlayFallbackY;\n      const overlayX = originX;\n      const overlayFallbackX = originFallbackX; // let [originY, originFallbackY] = [overlayY, overlayFallbackY];\n      // let [overlayX, overlayFallbackX] = [originX, originFallbackX];\n\n      /** Reverse overlayY and fallbackOverlayY when overlapTrigger is false */\n\n      if (!this.popover.overlapTrigger) {\n        originY = overlayY === 'top' ? 'bottom' : 'top';\n        originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n      }\n\n      let offsetX = 0;\n      let offsetY = 0;\n\n      if (this.popover.targetOffsetX && !isNaN(Number(this.popover.targetOffsetX))) {\n        offsetX = Number(this.popover.targetOffsetX); // offsetX = -16;\n      }\n\n      if (this.popover.targetOffsetY && !isNaN(Number(this.popover.targetOffsetY))) {\n        offsetY = Number(this.popover.targetOffsetY); // offsetY = -10;\n      }\n      /**\n       * For overriding position element, when mdePopoverTargetAt has a valid element reference.\n       * Useful for sticking popover to parent element and offsetting arrow to trigger element.\n       * If undefined defaults to the trigger element reference.\n       */\n\n\n      let element = this._elementRef;\n\n      if (typeof this.targetElement !== 'undefined') {\n        this.popover.containerPositioning = true;\n        element = this.targetElement._elementRef;\n      }\n\n      return this._overlay.position().flexibleConnectedTo(element).withLockedPosition(true).withPositions([{\n        originX,\n        originY,\n        overlayX,\n        overlayY,\n        offsetY\n      }, {\n        originX: originFallbackX,\n        originY,\n        overlayX: overlayFallbackX,\n        overlayY,\n        offsetY\n      }, {\n        originX,\n        originY: originFallbackY,\n        overlayX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY\n      }, {\n        originX: originFallbackX,\n        originY: originFallbackY,\n        overlayX: overlayFallbackX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY\n      }]).withDefaultOffsetX(offsetX).withDefaultOffsetY(offsetY);\n    }\n\n    _cleanUpSubscriptions() {\n      if (this._backdropSubscription) {\n        this._backdropSubscription.unsubscribe();\n      }\n\n      if (this._positionSubscription) {\n        this._positionSubscription.unsubscribe();\n      }\n\n      if (this._detachmentsSubscription) {\n        this._detachmentsSubscription.unsubscribe();\n      }\n    }\n\n    _handleMousedown(event) {\n      if (event && !isFakeMousedownFromScreenReader(event)) {\n        this._openedByMouse = true;\n      }\n    }\n\n  }\n\n  MdePopoverTrigger.ɵfac = function MdePopoverTrigger_Factory(t) {\n    return new (t || MdePopoverTrigger)(i0.ɵɵdirectiveInject(i1$1.Overlay), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i2$1.Directionality, 8), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  MdePopoverTrigger.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: MdePopoverTrigger,\n    selectors: [[\"\", \"mdePopoverTriggerFor\", \"\"]],\n    hostVars: 1,\n    hostBindings: function MdePopoverTrigger_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function MdePopoverTrigger_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"mouseenter\", function MdePopoverTrigger_mouseenter_HostBindingHandler($event) {\n          return ctx.onMouseEnter($event);\n        })(\"mouseleave\", function MdePopoverTrigger_mouseleave_HostBindingHandler($event) {\n          return ctx.onMouseLeave($event);\n        })(\"mousedown\", function MdePopoverTrigger_mousedown_HostBindingHandler($event) {\n          return ctx._handleMousedown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-haspopup\", ctx.ariaHaspopup);\n      }\n    },\n    inputs: {\n      popover: [\"mdePopoverTriggerFor\", \"popover\"],\n      targetElement: [\"mdePopoverTargetAt\", \"targetElement\"],\n      positionX: [\"mdePopoverPositionX\", \"positionX\"],\n      positionY: [\"mdePopoverPositionY\", \"positionY\"],\n      triggerEvent: [\"mdePopoverTriggerOn\", \"triggerEvent\"],\n      enterDelay: [\"mdePopoverEnterDelay\", \"enterDelay\"],\n      leaveDelay: [\"mdePopoverLeaveDelay\", \"leaveDelay\"],\n      overlapTrigger: [\"mdePopoverOverlapTrigger\", \"overlapTrigger\"],\n      targetOffsetX: [\"mdePopoverOffsetX\", \"targetOffsetX\"],\n      targetOffsetY: [\"mdePopoverOffsetY\", \"targetOffsetY\"],\n      arrowOffsetX: [\"mdePopoverArrowOffsetX\", \"arrowOffsetX\"],\n      arrowWidth: [\"mdePopoverArrowWidth\", \"arrowWidth\"],\n      arrowColor: [\"mdePopoverArrowColor\", \"arrowColor\"],\n      closeOnClick: [\"mdePopoverCloseOnClick\", \"closeOnClick\"],\n      backdropCloseOnClick: [\"mdePopoverBackdropCloseOnClick\", \"backdropCloseOnClick\"]\n    },\n    outputs: {\n      opened: \"opened\",\n      closed: \"closed\"\n    },\n    exportAs: [\"mdePopoverTrigger\"]\n  });\n  return MdePopoverTrigger;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdePopoverTarget = /*#__PURE__*/(() => {\n  class MdePopoverTarget {\n    constructor(_elementRef) {\n      this._elementRef = _elementRef;\n    }\n\n  }\n\n  MdePopoverTarget.ɵfac = function MdePopoverTarget_Factory(t) {\n    return new (t || MdePopoverTarget)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  MdePopoverTarget.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: MdePopoverTarget,\n    selectors: [[\"mde-popover-target\"], [\"\", \"mdePopoverTarget\", \"\"]],\n    exportAs: [\"mdePopoverTarget\"]\n  });\n  return MdePopoverTarget;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdePopoverModule = /*#__PURE__*/(() => {\n  class MdePopoverModule {}\n\n  MdePopoverModule.ɵfac = function MdePopoverModule_Factory(t) {\n    return new (t || MdePopoverModule)();\n  };\n\n  MdePopoverModule.ɵmod = /*@__PURE__*/i0.ɵɵdefineNgModule({\n    type: MdePopoverModule\n  });\n  MdePopoverModule.ɵinj = /*@__PURE__*/i0.ɵɵdefineInjector({\n    imports: [[OverlayModule, CommonModule, A11yModule]]\n  });\n  return MdePopoverModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(MdePopoverModule, {\n    declarations: [MdePopover, MdePopoverTrigger, MdePopoverTarget],\n    imports: [OverlayModule, CommonModule, A11yModule],\n    exports: [MdePopover, MdePopoverTrigger, MdePopoverTarget]\n  });\n})();\n/*\n * Public API Surface of mde\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MdePopover, MdePopoverModule, MdePopoverTarget, MdePopoverTrigger, transformPopover }; //# sourceMappingURL=material-extended-mde.mjs.map","map":null,"metadata":{},"sourceType":"module"}